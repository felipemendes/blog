{"componentChunkName":"component---src-templates-blog-post-js","path":"/chuck-facts/","result":{"data":{"site":{"siteMetadata":{"title":"Felipe Mendes"}},"markdownRemark":{"id":"e481ec52-8ed8-5455-a538-2b5ed88a28b6","excerpt":"Nesta postagem, compartilho um pouco das práticas e processos que utilizei no desenvolvimento do aplicativo para iOS Chuck Facts. O código fonte está disponível…","html":"<p>Nesta postagem, compartilho um pouco das práticas e processos que utilizei no desenvolvimento do aplicativo para iOS Chuck Facts. O código fonte está disponível no repositório <a href=\"https://github.com/felipemendes/ChuckFacts\">ChuckFacts</a>.</p>\n<p>Em resumo, o projeto possibilita realizar buscas em <a href=\"https://api.chucknorris.io/\">api.chucknorris.io</a>, exibir os resultados consultados e realizar o compartilhamento dos fatos.</p>\n<p>Existem várias maneiras de se resolver um problema. No entanto, a maneira que o problema é abordado depende muito do gosto pessoal e da situação atual do projeto. Com este post, espero que você aprenda algo útil do meu ponto de vista no desenvolvimento dessa aplicação.</p>\n<p>Este é o resultado final:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/98a97492df34ecd2b2a5fdc9c23e143c/8ae3e/chuck-facts.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.89873417721519%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACP0lEQVQoz1WSS0/bUBSE83PpCrGh6hKBxCaquqBsSmmrLFLCuqiwAIIEVRVRkULSlCSExLEd2/ErdvzK4+v1perjSqPrY9lzZuacQpZlzOdzFosFaZoynU6J45QkzX4jJYpjqtUql5eXtFotLi4uODs7I4wSJkFAIBCGIb7vU7DtMf1+H9M0yU/eII0CltlUVHOJ5WLO3t4bnq+vs7Gxwfb2NgcHB5h2iKZbaOpIkIWCNKIwMkwazR/0ej2GqkqWxpw2Ao7qEaf3cD1Yonrwdv8d689fsLm5ydbWFpVKhZFuo6q6cBWTJMJNklLwJ6FQZzGZ+FJ+liZ0jIy6ktLUl5gBzOYLyh8rFF++4vXODsVikcPDQ/FPxGhk43mhRF4XrLFNs3VPu90W0lWiKMJ3LLLI59+zu7vLs5UV1tbWWF1dpVQqSYuW5QiFiXiOpVKhMEDVDUzDQNd1GfAkCEmzmRjSTN55rp+OPrP/viStlstlTk5OBEmCbQc4zhN8f0phbLu0H/oMBgOZ40RMaihCvu/06HT7dB7E+76K67pks5nYgFjC81xpMydy3fAvoev59B4HDIdDNE2Tlg3DErWGMtRF8BqmrjBQVExrLFcjXy3Hcf4Q/qfw8bHP+XmVq6srbm9vZffvdy26PYWJ5/C1afDh+AF1qIhGJuOxI3fOsixJmKvz/UgQhk+EU7HEYzcQHxtS3UzYur5pUPvW4O6uyXmtw3FNo9P+yU29zpdaXTbudrsi71gQeyiKLu98yr8AJJrUbXaEr4EAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Chuck Facts\"\n        title=\"Chuck Facts\"\n        src=\"/static/98a97492df34ecd2b2a5fdc9c23e143c/f058b/chuck-facts.png\"\n        srcset=\"/static/98a97492df34ecd2b2a5fdc9c23e143c/c26ae/chuck-facts.png 158w,\n/static/98a97492df34ecd2b2a5fdc9c23e143c/6bdcf/chuck-facts.png 315w,\n/static/98a97492df34ecd2b2a5fdc9c23e143c/f058b/chuck-facts.png 630w,\n/static/98a97492df34ecd2b2a5fdc9c23e143c/8ae3e/chuck-facts.png 756w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>Iniciando</h2>\n<p>Para facilitar a identificação e divisão de tarefas, utilizei o GitHub Projects com automação dos <em>cards</em> com as <em>issues</em> do projeto. O quadro que criei se chama MLP (<em>Minimum Loveable Product</em>) e pode ser encontrado <a href=\"https://github.com/felipemendes/ChuckFacts/projects/1\">aqui</a>.</p>\n<h2>Sistema de controle de versão</h2>\n<p>Ao iniciar um novo projeto, a primeira linha de comando que sempre digito é <code class=\"language-text\">git init</code>. O sistema de controle de versão é um processo imprescindível no desenvolvimento de aplicativos e sistemas, sendo o <code class=\"language-text\">Git</code>, na minha opinião, a melhor e mais completa alternativa para trabalhar em equipes e controlar todo o processo.</p>\n<h2>Configuração inicial</h2>\n<p>No <em>Xcode</em>, para facilitar a organização de grupos (diretórios) e arquivos, deixei o projeto configurado com o mínimo de informação possível. Isso porque tal forma de organização coloca o projeto em perspectiva, ajudando, assim, a pensar na melhor arquitetura a ser utilizada e no objetivo da aplicação. A fim de escrever um código mais limpo e facilitar o seu versionamento de, não utilizei <em>Storyboards</em> e <em>XIBs</em>. Assim, a alternativa que escolhi foi a de desenvolver as telas e elementos visuais programaticamente, isto é, por meio de <em>view code</em>.</p>\n<p>Para facilitar o desenvolvimento de layout, utilizei o serviço <a href=\"https://www.wtfautolayout.com/\">WTF Auto Layout?</a> para deixar o <em>log</em> de erros mais legível.</p>\n<h2>Style guide</h2>\n<p>Para melhorar a leitura e integração de novos membros ao projeto, fiz uso do <em>style guide</em> de <em>Swift</em> do <a href=\"https://github.com/raywenderlich/swift-style-guide\">Raywenderlich</a>. Ferramentas de <em>linter</em> também entraram na minha receita. O uso do <em><a href=\"https://github.com/realm/SwiftLint\">SwiftLint</a></em> ajuda a impor um estilo de código para todos os envolvidos e promove as melhores práticas recomendadas na programação.</p>\n<h2>Gerenciador de dependências</h2>\n<p>Nesse projeto optei em utilizar também o <em>Cocoapods</em> por ser ele um gerenciador muito fácil de configurar e de integrar novas dependências ao projeto. Destaco, ainda, que seu uso também é muito simplificado tanto para a integração de dependência quanto para a construção de novas bibliotecas, conforme explico <a href=\"https://felipemendes.netlify.com/bibliotecas-com-cocoapods/bibliotecas-com-cocoapods/\">nesta</a> postagem.</p>\n<h2>Arquitetura</h2>\n<p>Tentei organizar ao máximo o código por <em>módulos/features</em>, uma vez que facilita a identificação de códigos relacionados para correção e adição de novos recursos no futuro de uma maneira mais simplificada. Essa organização responde à pergunta “O que esse aplicativo faz?” em vez de “O que é esse arquivo ou o que ele faz?”. O maior benefício é tornar tudo modular e facilitar o seu desenvolvimento, bem como seus respectivos testes.</p>\n<p>Aqui foram criadas as <em>features</em> e <em>components</em>:</p>\n<ul>\n<li>Home;</li>\n<li>Search;</li>\n<li>CloudTag;</li>\n<li>PastSearches;</li>\n<li>Placeholder.</li>\n</ul>\n<h2>MVVM</h2>\n<p>Existem diversas maneiras para arquiteturar um aplicativo, sendo o <em>MVC (Model View Controller)</em> da Apple mais usado no desenvolvimento iOS. Esse modelo é popularmente conhecido como <em>Massive View Controller</em> por causa de sua falta de abstração. Dessa forma, objetivando de resolver essa questão, escolhi utilizar o <em>MVVM (Model-View-ViewModel)</em>. O uso do <em>MVVM</em> permite tirar parte da lógica de apresentação da <em>ViewController</em> e, consequentemente, facilitar a manutenção do código e evolução de um projeto.</p>\n<h2>FlowController</h2>\n<p>Semelhante ao padrão <em>Coordinator</em>, o <em>FlowController</em> tem como propósito fornecer um encapsulamento da lógica de navegação. Desse modo, forma as <em>ViewControllers</em> ficam isoladas e invisíveis entre si, o que possibilita o reuso mais fácil. Basicamente, o <em>FlowController</em> é um container de <em>ViewControllers</em> para resolver um fluxo de navegação interno. Normalmente, utilizo um <em>Flow</em> para cada <em>feature</em>, de modo que cada ação possui um método próprio para realizar a navegação.</p>\n<h2>Injeção de dependência</h2>\n<p>Cada <em>ViewController</em>, dentro do <em>FlowController</em>, pode ter dependências diferentes. Isso evita que o primeiro <em>ViewController</em> carregue todas as instâncias (ex.: um serviço) e passe para as <em>ViewControllers</em> filhas. Para ajudar a divisão de componentes que serão desenvolvidas, testadas e mantidas com mais facilidade, utilizei o <a href=\"https://github.com/Swinject/Swinject\">Swinject</a> como framework de Injeção de Dependência.</p>\n<h2>Testes unitários</h2>\n<p>Para os <em>unit tests</em> utilizei somente o framework <em>XCTest</em> da Apple. Para cada componente que foi testado foi criado um arquivo de <em>XCTest</em> no <em>target</em> de testes. Recomenda-se criar uma função para cada comportamento, bem como ser o mais minucioso na descrição da assinatura de cada método. Por outro lado, apesar de não ser aconselhado, também criei testes de requisições dos <em>endpoints</em> de produção. O ideal seria criar mocks que representam o ambiente.</p>\n<h2>Camada de serviços</h2>\n<p>A implementação de serviços normalmente gera dúvidas sobre qual abordagem deve ser seguida: utilizar bibliotecas externas, como Moya e Alamofire, ou desenvolver manualmente? Por mais que essas <em>libs</em> sejam acessíveis e sejam de uso simplificado, tentei limitar a quantidade de dependências na aplicação e assim evitar problemas com atualizações ou erros de códigos externos.</p>\n<p>As requisições ficaram organizadas da seguinte maneira:</p>\n<ul>\n<li><strong>Endpointable</strong> é um protocolo que possui as propriedades necessárias para a criação da <em>URLRequest</em>.</li>\n<li><strong>HTTPMethod</strong> é um <em>enum</em> responsável pelos métodos de requisição HTTP. Nesse caso, somente o tipo <em>get</em> foi configurado.</li>\n<li><strong>HTTPTask</strong> é um <em>enum</em> que configura os parâmetros dos <em>endpoints</em> dos serviços.</li>\n<li><strong>Routable</strong> este protocolo possui um <em>endpointable</em> responsável por fazer as requisições e o método <em>request()</em> retorna o seu resultado.</li>\n<li><strong>Router</strong> cria uma <em>URLSession</em> a partir do <em>endpointable</em>. O retorno da requisição é enviado para <em>URLSession.shared</em>. Aqui, também é feito o <em>encoding</em> dos parâmetros na URL.</li>\n</ul>\n<h2>Armazenamento de dados</h2>\n<p>Por fim, para a persistência dos dados, utilizei o framework <em>CoreData</em> da Apple. Criei o gerenciamento e a manipulação básica de objetos devido ao tipo de dados que estão salvos. O armazenamento ocorre somente para as pesquisas realizadas pelo usuário. A cada pesquisa realizada, a função <em>add(_ keyword: String)</em> é invocada, de modo que toda a lógica é realizada e o armazenamento é feito, se necessário. A recuperação desses dados, por sua vez, foi feita por meio de <em>observable</em>. A exclusão dos registros se deu por intermédio das configurações do aplicativo dentro de Ajustes do prórpio iOS.</p>","frontmatter":{"title":"Pet Project: Chuck Facts","date":"December 11, 2019","description":""}},"previous":{"fields":{"slug":"/funcao-com-parametro-in-out/"},"frontmatter":{"title":"Função com parâmetro In-Out"}},"next":{"fields":{"slug":"/usernotifications-framework/"},"frontmatter":{"title":"UserNotifications Framework"}}},"pageContext":{"id":"e481ec52-8ed8-5455-a538-2b5ed88a28b6","previousPostId":"669ab285-44af-5d6c-a344-8ba29164d871","nextPostId":"3d97bfac-1122-5254-a720-457d335b1e08"}},"staticQueryHashes":["1344965497","2841359383"]}